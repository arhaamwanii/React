                       REACT

-front end framework
-there are seme custom elements in this which are not in traditional one
-mixing of different type of files(HTML, CSS, JS)
-we can differentite things in react using which then we can make that single thing do a thing without refreshing the whole website
-Re-renders this only in that part





                            ES6

TEMPLATE LITERALS 

- they can be creates using   ``
-it is a way to work with  strings
-Combining strings using template literals = 
    >`` you have to put the whole content in backticks
    > ${} using this the variable or the text can be specified
            let name1 = prompt("You first name");
            let name2 = prompt("Your last name");

            let fullName = `${name1} ${name2}`

            document.getElementById("example").innerHTML = fullName;

STRUCTURING OBJECTS

-it is used to bind values from the objects to a Variable
       -const me = { 
            name: "arham",
            age: "17 year and 3 month ",
            ability: "obsession",
        }

        const {name, age , ability } = me;

        let all = (`${name}  ${age}  ${ability}` )

        document.getElementById("heading").innerHTML = all ;

        console.log(all);

-const{name , age , ability} = me;
-this is used to to name the variables to be used outside as well - "name: hello" this can be used to reaname the thing outside the object 


DESTRUCTURING ARRAYS

you are basically making variable and a array at the same time time  

    let [one , two , three , four , five ] = ['arham' , 23 , "amin" , "wani" , "12342342"];

OBJECT LITERALS
-



FOR OF 
-it is basically used to loop of the whole thing, and see the value individually

    let  full = [200 , 600 , 400];

    for ( const text of full){
        console.log(text);
    }

SPRED OPERATORS

-making a copy of an array or objects

 -  let contacts = ["Mary", "Joel", "Danny"];

    let personalFriends = ["david",  ...contacts , "lilly" ];

    contacts.push("John");

    console.log(personalFriends);

- "...variablename" this here creates a copy of the array or ojject isde the new object
OBJECT

-   let employee = {
        ...person,
        salary: 50000,
        position: "Software Developer"
    }

    console.log(employee);

REST OPERATORS

if you write a function and dont know how many paramertes will be entered you can use this

    function add(...nums) {
        
        console.log(nums);
    }

    add(4, 5, 7, 8, 12)

-...nums is used to take more than one parameter as imputs

ARROW FUNCTIONS

-       const dinnerMenu = (food) => {
            return `I'm going to eat a ${food} for dinner`;
        }

        console.log( dinnerMenu("chicken salad") );


ANONYMOUS FUNCTION 

-they are used to make functions  inside functions which are not to be used any where else


DEFAULT PARAMS
- it is used to make put in default paramerter, in case no prameter is passed while calling the function
-   const leadSinger = (artist = "someone")

-in this case if you dont put in the value while calllig the function someone will aoutomatically be put in.


.indexOf
-it is used to count number of charecters and also the number of elements inside an arary

.includes
it is used to check wether an array has that element or not



cost 
-in this case you cant change the data type 
-you can push a value inside a array or a object which is defined via const 
-text

padStart & padIn
-add numbers or text in the string or ending to make the string fit the the length you want it to be


THIS 
    function yourName(name){

        let legs = "anything" ;

        this.legs = name;
        console.log(this.legs)
    
        console.log(legs)
    }

    yourName("Arham Amin Wani");


OBJECT ORIENTED PROGRAMMING

-Object-oriented programming (OOP) is a programming paradigm that uses objects and classes for organizing and structuring code. It is a way of designing software using the concept of objects, which can contain data in the form of fields (often known as attributes or properties) and code, in the form of procedures (often known as methods).
-it has to do with, classes , obejects and methods... you can predefine stuff
-centeren around objects, rather than FUNCTIONS
-It also has specific propeties
-Method is basically an function inside a object
-4 PILLARS

ENCAPSULATION

     let myDetails = {
        name: "Arham",
        residency: "Dalgate",
        age: "17 years and 3 months",
        timeIn: 18,
        laverage: 3,
        outPut: function(){
            return this.timeIn * this.laverage;
        }
    };


    let out = myDetails.outPut(45 , 11000);
    
    console.log(out);

ABSTRACTION

    -complexity is hidden
    -reduces impact of change
    -we can call  a specific thing only and we are good to go

INHERITANCE

    - we can first define things that allow us to communicate with the html and other stuff than we can simply call those and use them insted

POLY-MORPHISHM

    -get rid of if else complexity
    -refacrtor switch case statements 



FACTORY 

function fst(radius){
    return {

        //ket value pairs - PROPERTIES
        
            pp: radius =  "2442",
        
        //FUNCTION - METHOD(logic)
        
            draw: function(){
                console.log(radius);
            },

            one: function() {console.log(radius)}
        };
        
}

const prduct1 =  fst(144);

prduct1.draw();

console.log(prduct1)


//we created a function/factory and we named it fst -- we put in the a parameter which we are going to use to diffenrntite between the differnt objects this factory is going to return us
//inside there wer put in a property and an method, 
    //in the property we redfined the value of radius, which otheerwise we had defined when calling the function
    //in the function we put a loggig the value of radius on the cosole command
//then we called this ffactory using paramerters and then stored the value in const "product1",
//what it basically did is that created a new object and stored that value in product1 - with the parameter provided while calling the function 
//now we can acess that object using the "prduct1" keyword and can acess its properties and method like this
    //product1.propertyName         
    //product1.methodName()


CONSTRUCTORS

-it is used to determine the parameters specific to the object we are going to create  using the class thing

-   class Animal{
        constructor(one  , two){
            this.legs = one;
            this.arms = two;
        }
    };

    let human = new Animal("two arms" , "two legs");
    console.log(human.legs)
    console.log(human.arms)

    const dog = new Animal("four legs " , "four arms");



//OBJECT-FACTORY and CLASSES  basically so the same thing
//first we difined a class named "Animals" - first letter is capial because it is comsidered good practise
//inside  the class we puted in a CONSTRUCTOR whcih was is used to put in parameters inside when we call the function
//inside we can define the code we need to use these parameters for
//'THIS' refers to the name of the animal in this case which we are going to set using the "new" keyword , the name of the variable given there will be the name of "THIS" in that case     "let human = new Animal "
// we put the name of the property or function in that case using "this.name" - name here determines the name of the function or propeerty in that which will be specific to the "this" -- this is the name determined while calling the class
// then we puted this property equal to the parameter we got while calling the class - these paraemters are specific to every object created from the class
// CALLING THE CLASS - 
//whatever we keep the name of the variable while calling the class will be the name of that class(THIS will be specified to it)  
//"NEW" keyword here determines the making of a new object
//then we call the fumction and put in the parameter specific to the name of the variable in that case


EXTENDING A CLASSES

    class FootBallPlayer {
            constructor(playerName ,  age , country){
                this.name = playerName;
                this.age = age;
                this.country  = country;
            
            }
            text() {
                console.log(`my name is ${this.name} am ${this.age} , curretly living in ${this.country}`)
            }

        }


    let messi = new FootBallPlayer( "messi" , 37 , "usa");
    Let ronaldo = new FootBallPlayer("ronaldo" , 38 , "pourtgal")


        messi.text();
        ronaldo.text();


        class TennisPlayer extends FootBallPlayer{
            constructor( playerName, age , country , hits){
                super(playerName , age , country);
                this.playerName  =  playerName;
                this.age = this.age;
                this.country = this.country;
                this.hits = 1213;
            }
            
                text2(){
                    console.log(`am a tennis player , my name is ${this.playerName} i live in ${this.country} i had ${this.hits} hits till now `)
                }
            }


        let rafael  = new TennisPlayer("rafel" , 32 , "someplace" , 23);

        rafael.text2();

-in this case we extend FootballPlayer to TennisPlayer but we want to to include the parameters from the FootballPlayer
-"SUEPER" here is used to inHerit the perimeters from the class FootballPlayer  -  the parameters you put in here  that match the footBallPlayer will be imported here
    -you also have to include them in the CONSTRUCTOR keyword tho 




GET
-similar to using a return statement



PROMISES

    -used on network requests
    -fetch data
    -promise leading to a result - which is either resolved or rejected

        let prom = new Promise((resolve, reject) => {
        let  a = 1 + 1
        if(a == 2){
                resolve("shit is Working")
            }else{
                reject("shit is not working")
            }
        })


        prom.then((message) => {
            console.log("this is in the then, - " + message)
        })
        prom.catch((message) => {
            console.log("this is in the catch, - " + message)
        })


        //then is used when a promise is resolves i.e it is fullfilled  -- is going to run for reslove
        //we create a new js object and name it prom 
        //we put in two in built functions related to promise  - resolve and reject as the parameters to the inbuilt object promise
        //then we define the function  and and the conditions for resolve and reject in there

        //once the inital conditions are defined we ca define the outPut
            //.then will be used to deifine the result for --"RESOLVE"
            //.cath is used to define the result for --"REJECT"

    -promises are mailnly used toc make something do in the  background


COC 

    -promises represt the eventual competion or rejection of an Asyncrous function
    -i.e    it represents the on off of an operation that is going on in the background
    -it is an promise




FETCH
-mainly used to do API calls
-before it  wass xmlhttprequest
-ashyncronus was hard before




ASYNC

        DEFAULT
    - js fundamentaly is a syncronus language - one after one
    -single thread language

    -asynchronus code - working in the background
    -any function can be made ASYNC
    -then we can await a prmoise inside it 
    -the values inside are automatically wraped in a promise,

    AWAIT 
        -it is used to wait before fotr the promise to be full filled




















CODE EXECUTION IN JS + EXECUTION CONTEXT + CALL STACK

-js execution context 
-runned in two phases
GLOBAL EC
-put in this(windiow object browser )
-eval execution context this is  a type of global EC(moongose)
FUNCTIONAL EC 
-
-

MEMORY CREATION PHASE
EXECUTION PHASE
    
STEPS
    global execution - allocated in this 
    memory phases
        var 1 = uderfined
        var 2 = undefined

        addnum - res of the code

        result  1 = undefined
        result 2  = undefined

EXECUTION PHASE

    new executalble environment will be made - (new execution context)
    execution thread

        memory phase will re happen again for this environment now 
        var 1 
        var 2 
        traditional

        execution context wil rehappen here also 






                            CHAI AND CODE - react 












































            



